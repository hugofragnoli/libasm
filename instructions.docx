Chapter III
Mandatory part
‚Ä¢ The library must be called libasm.a.
‚Ä¢ You must submit a main function that will test your functions and compile with
your library to demonstrate that it is functional.
‚Ä¢ You must rewrite the following functions in assembly:
‚ó¶ ft_strlen (man 3 strlen)
‚ó¶ ft_strcpy (man 3 strcpy)
‚ó¶ ft_strcmp (man 3 strcmp)
‚ó¶ ft_write (man 2 write)
‚ó¶ ft_read (man 2 read)
‚ó¶ ft_strdup (man 3 strdup, you can call to malloc)
‚Ä¢ You must check for errors during syscalls and handle them properly when needed.
‚Ä¢ Your code must set the variable errno properly.
‚Ä¢ For that, you are allowed to call the extern ___error or errno_location

Bonus part
You can rewrite these functions in assembly. The linked list functions will use the follow-
ing structure:
typedef struct s_list
{
void *data;
struct s_list *next;
} t_list;
‚Ä¢ ft_atoi_base (see Annex V.1)
‚Ä¢ ft_list_push_front (see Annex V.2)
‚Ä¢ ft_list_size (see Annex V.3)
‚Ä¢ ft_list_sort (see Annex V.4)
‚Ä¢ ft_list_remove_if (see Annex V.5)

    ///////////////////////////////////////

pour le fun : 

strlen recursif 

global _ft_strlen

_ft_strlen:
    cmp byte [rdi], 0       ; '\0'? 
    jz .empty               ;

    inc rdi                 ; (*str++)
    call    ft_strlen       ; Rax recoit le res de la suite.

    inc rax                 ; ON ajoute +1 au res.
    ret                     ; On rend la main au parent.

.empty:
    xor rax, rax            ; On met rax a 0
    ret                     ; on remonte le premier a 0

    ///////////////////////////////////////

; La convention ABI dit : "Si tu touches √† RBX, R12, R13, R14 ou R15, 
    ; tu dois les rendre dans le m√™me √©tat qu'√† l'entr√©e".
    Donc si on push dessus on doit tjrs pop a la fin.


    ///////////////////////////////////////

1. La "Poup√©e Russe" des registres
En x86_64, les registres sont imbriqu√©s. EAX, ce sont simplement les 32 bits de poids faible de RAX.

RAX : 64 bits (Le registre complet)

EAX : 32 bits (La moiti√© basse)

AX : 16 bits

AL / AH : 8 bits

    ///////////////////////////////////////

;Pour swap :
; RDI = pointeur A, RSI = pointeur B
;mov rax, [rdi]    ; Charger valeur A dans RAX (temporaire)
;mov rdx, [rsi]    ; Charger valeur B dans RDX
;mov [rdi], rdx    ; Mettre valeur B √† l'adresse A
;mov [rsi], rax    ; Mettre valeur A (stock√©e dans RAX) √† l'adresse B 

///////////////////////////////

ASTUCE :
Pour faire multiple de 64 on peut faire   
sub rsp, 8              ; on retire 8 octets pour aligner la pile (56 + 8 = 64 donc multiple de 16)
add rsp, 8              ; on ajoute 8 octets pour aligner la pile (56 - 8 = 48 donc multiple de 16)

//////////////////////////////////////////////

Pour compiler ton projet sur les machines Linux AMD64 de ton √©cole, tu vas devoir effectuer des modifications sur ton Makefile et sur l'ensemble de tes fichiers Assembleur (.s).Voici les changements pr√©cis √† appliquer :1. Modification du MakefileLe format de fichier binaire et la gestion des symboles diff√®rent entre macOS (macho64) et Linux (elf64).NASM_FLAGS : Remplace -f macho64 par -f elf64.Les Underscores : Sur Linux, les fonctions C n'ont pas besoin de l'underscore _ devant leur nom.Flags de Compilation C : Le flag -arch x86_64 est sp√©cifique √† macOS ; tu peux le supprimer pour Linux.Extrait du Makefile modifi√© :MakefileNASM        = nasm
NASM_FLAGS  = -f elf64  # Chang√© de macho64 √† elf64

# ... (reste du code)

test: all
	cc -Wall -Wextra -Werror $(MAIN_SRC) $(NAME) -o $(TEST_NAME) # Suppression de -arch x86_64
2. Modification des Fichiers Assembleur (.s)Tu dois retirer les underscores devant les noms des fonctions globales et les appels externes.Symboles Globaux : Remplace global _ft_strlen par global ft_strlen.Appels Externes : Remplace extern ___error par extern __errno_location (sur la plupart des syst√®mes Linux) ou simplement extern errno.Appels de fonctions : Remplace call _malloc par call malloc.Exemple avec ft_strcmp.s :Extrait de code; Avant (macOS)
global  _ft_strcmp
_ft_strcmp:
    ; ...

; Apr√®s (Linux)
global  ft_strcmp
ft_strcmp:
    ; ...
3. Gestion des Appels Syst√®me (System Calls)C'est le changement le plus critique. Les IDs des appels syst√®me et la mani√®re de g√©rer les erreurs (errno) sont diff√©rents sur Linux.ft_write.s sur Linux :Sur Linux, le code pour write est 1 (au lieu de 0x02000004). De plus, syscall retourne une valeur n√©gative entre -1 et -4095 en cas d'erreur, au lieu d'utiliser le "Carry Flag".Extrait de codeextern __errno_location ; Fonction Linux pour errno
global ft_write

ft_write:
    mov rax, 1          ; Code sys_write sur Linux
    syscall             
    cmp rax, 0          ; V√©rifie si RAX est n√©gatif
    jl .error           
    ret

.error:
    neg rax             ; On rend le code d'erreur positif (ex: -9 devient 9)
    mov rdi, rax        ; Sauvegarde le code
    call __errno_location ; RAX contient maintenant l'adresse d'errno
    mov [rax], rdi      ; *errno = code_erreur
    mov rax, -1         ; Retourne -1
    ret
4. R√©sum√© des changements de syscall IDsFonctionCode macOSCode Linux (AMD64)sys_read0x020000030sys_write0x020000041üí° Conseil pour la portabilit√©Si tu veux que ton code fonctionne sur les deux syst√®mes sans tout r√©√©crire √† chaque fois, tu peux utiliser des macros NASM au d√©but de tes fichiers :Extrait de code%ifidn __OUTPUT_FORMAT__, elf64
    %define FT_WRITE ft_write
    %define SYSCALL_WRITE 1
%else
    %define FT_WRITE _ft_write
    %define SYSCALL_WRITE 0x02000004
%endif

global FT_WRITE
Veux-tu que je t'aide √† r√©√©crire sp√©cifiquement ft_read.s pour Linux avec la gestion d'erreur cmp rax, 0 ?